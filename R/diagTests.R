#' @title Perform adjusted Portmanteau test for a STVAR model
#'
#' @description \code{Portmanteau_test} performs adjusted Portmanteau test for remaining autocorrelation
#'   (or heteroskedasticity) in the residuals of a STVAR model.
#'
#' @param stvar an object of class \code{'stvar'} generated by \code{fitSTVAR} or \code{STVAR}.
#' @param nlags a strictly positive integer specifying the number of lags to be tested.
#' @param type should test for remaining autocorrelation or heteroskedasticity be calculated?
#' @details The implemented adjusted Portmanteau test is based on L端tkepohl (2005), Section 4.4.3.
#'   When testing for remaining heteroskedasticity, the Portmanteau test is applied to squared
#'   standardized residuals. Note that the validity of the heteroskedasticity test requires that the
#'   residuals are not autocorrelated.
#' @return A list with class "hypotest" containing the test results and arguments used to calculate the test.
#' @seealso \code{\link{LR_test}}, \code{\link{Rao_test}}, \code{\link{fitSTVAR}}, \code{\link{STVAR}},
#'   \code{\link{diagnostic_plot}}, \code{\link{profile_logliks}},
#' @references
#'   \itemize{
#'    \item L端tkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
#'            \emph{Springer}.
#'   }
#' @examples
#' # FILL IN
#' @export

Portmanteau_test <- function(stvar, nlags=20, which_test=c("autocorr", "het.sked")) {
  which_test <- match.arg(which_test)
  if(is.null(stvar$residuals_raw) && which_test == "autocorr") {
    stop("The model needs to contain residuals_raw for autocorrelation test")
  } else if(is.null(stvar$residuals_std) && which_test == "het.sked") {
    stop("The model needs to contain residuals_std for heteroskedasticity test")
  }
  if(length(nlags) != 1 || nlags < 1 || nlags%%1 != 0) {
    stop("The argument nlags should be a strictly positive interger")
  }
  n_params <- length(stvar$params)
  p <- stvar$model$p
  M <- stvar$model$M
  d <- stvar$model$d
  if(which_test == "autocorr") {
    U <- t(stvar$residuals_raw)
  } else { # which_test == het.sked
    U <- t(stvar$residuals_std^2) # Test applied to squared standardized residuals
  }
  T_obs <- ncol(U) # U = (d x T_obs)

  # Function that calculates the matrix C_i given in L端tkepohl (2005), Equation (4.4.1).
  get_Ci <- function(i) { # T_obs and U taken from the parent environment
    U%*%tcrossprod(create_Fi_matrix(i=i, T_obs=T_obs), U)/T_obs
  }
  # get_Ci2 <- function(i) {
  #   ret <- matrix(0, ncol=d, nrow=d)
  #   for(i1 in (i + 1):T_obs) {
  #     ret <- ret + tcrossprod(U[,i1], U[,i1 - i])
  #   }
  #   ret/T_obs
  # }

  # K = d, nlags = h

  # Calculate the test statistic, L端tkepohl (2005), Equation (4.4.23)
  inv_C_0 <- solve(get_Ci(i=0))
  tmp_q <- numeric(nlags)
  for(i1 in 1:nlags) {
    C_i <- get_Ci(i=i1)
    tmp_q[i1] <- sum(diag(crossprod(C_i, inv_C_0%*%C_i%*%inv_C_0)))/(T_obs - i1)
  }
  test_stat <- T_obs^2*sum(tmp_q)

  # Calculate the p-value
  df <- d^2*(nlags - p)
  p_value <- pchisq(test_stat, df=df, lower.tail=FALSE)

  # Return
  structure(list(stvar=stvar,
                 df=df,
                 test_stat=test_stat,
                 p_value=p_value,
                 type="Portmanteau test",
                 which_test=which_test),
             class="hypotest")
}

