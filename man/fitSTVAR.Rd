% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MAINest.R
\name{fitSTVAR}
\alias{fitSTVAR}
\title{Two-phase maximum likelihood estimation of a reduced form smooth transition VAR model}
\usage{
fitSTVAR(
  data,
  p,
  M,
  weight_function = c("relative_dens", "logistic", "mlogit", "exponential", "threshold"),
  weightfun_pars = NULL,
  cond_dist = c("Gaussian", "Student"),
  parametrization = c("intercept", "mean"),
  AR_constraints = NULL,
  mean_constraints = NULL,
  weight_constraints = NULL,
  nrounds = (M + 1)^5,
  ncores = 2,
  maxit = 1000,
  seeds = NULL,
  print_res = TRUE,
  use_parallel = TRUE,
  filter_estimates = TRUE,
  ...
)
}
\arguments{
\item{data}{a matrix or class \code{'ts'} object with \code{d>1} columns. Each column is taken to represent
a univariate time series. Missing values are not supported.}

\item{p}{a positive integer specifying the autoregressive order}

\item{M}{a positive integer specifying the number of regimes}

\item{weight_function}{What type of transition weights \eqn{\alpha_{m,t}} should be used?
\describe{
  \item{\code{"relative_dens"}:}{\eqn{\alpha_{m,t}=
    \frac{\alpha_mf_{m,dp}(y_{t-1},...,y_{t-p+1})}{\sum_{n=1}^M\alpha_nf_{n,dp}(y_{t-1},...,y_{t-p+1})}}, where
    \eqn{\alpha_m\in (0,1)} are weight parameters that satisfy \eqn{\sum_{m=1}^M\alpha_m=1} and
    \eqn{f_{m,dp}(\cdot)} is the \eqn{dp}-dimensional stationary density of the \eqn{m}th regime corresponding to \eqn{p}
    consecutive observations. Available for Gaussian conditional distribution only.}
  \item{\code{"logistic"}:}{\eqn{M=2}, \eqn{\alpha_{1,t}=1-\alpha_{2,t}},
    and \eqn{\alpha_{2,t}=[1+\exp\lbrace -\gamma(y_{it-j}-c) \rbrace]^{-1}}, where \eqn{y_{it-j}} is the lag \eqn{j}
    observation of the \eqn{i}th variable, \eqn{c} is a location parameter, and \eqn{\gamma > 0} is a scale parameter.}
  \item{\code{"mlogit"}:}{\eqn{\alpha_{m,t}=\frac{\exp\lbrace \gamma_m'z_{t-1} \rbrace}
    {\sum_{n=1}^M\exp\lbrace \gamma_n'z_{t-1} \rbrace}}, where \eqn{\gamma_m} are coefficient vectors, \eqn{\gamma_M=0},
    and \eqn{z_{t-1}} \eqn{(k\times 1)} is the \eqn{\mathcal{F}_{t-1}}-measurable vector containing a constant and
    the (lagged) switching variables.}
  \item{\code{"exponential"}:}{\eqn{M=2}, \eqn{\alpha_{1,t}=1-\alpha_{2,t}},
    and \eqn{\alpha_{2,t}=1-\exp\lbrace -\gamma(y_{it-j}-c) \rbrace}, where \eqn{y_{it-j}} is the lag \eqn{j}
    observation of the \eqn{i}th variable, \eqn{c} is a location parameter, and \eqn{\gamma > 0} is a scale parameter.}
  \item{\code{"threshold"}:}{\eqn{\alpha_{m,t} = 1} if \eqn{r_{m-1}<y_{it-j}\leq r_{m}} and \eqn{0} otherwise, where
     \eqn{-\infty\equiv r_0<r_1<\cdots <r_{M-1}<r_M\equiv\infty} are thresholds \eqn{y_{it-j}} is the lag \eqn{j}
     observation of the \eqn{i}th variable.}
}
See the vignette for more details about the weight functions.}

\item{weightfun_pars}{\describe{
  \item{If \code{weight_function == "relative_dens"}:}{Not used.}
  \item{If \code{weight_function \%in\% c("logistic", "exponential", "threshold")}:}{a numeric vector with the switching variable
    \eqn{i\in\lbrace 1,...,d \rbrace} in the first and the lag \eqn{j\in\lbrace 1,...,p \rbrace} in the second element.}
  \item{If \code{weight_function == "mlogit"}:}{a list of two elements:
    \describe{
      \item{The first element \code{$vars}:}{a numeric vector containing the variables that should used as switching variables
        in the weight function in an increasing order, i.e., a vector with unique elements in \eqn{\lbrace 1,...,d \rbrace}.}
      \item{The second element \code{$lags}:}{an integer in \eqn{\lbrace 1,...,p \rbrace} specifying the number of lags to be
        used in the weight function.}
    }
  }
}}

\item{cond_dist}{specifies the conditional distribution of the model as \code{"Gaussian"} or \code{"Student"}.}

\item{parametrization}{\code{"intercept"} or \code{"mean"} determining whether the model is parametrized with intercept
parameters \eqn{\phi_{m,0}} or regime means \eqn{\mu_{m}}, m=1,...,M.}

\item{AR_constraints}{a size \eqn{(Mpd^2 x q)} constraint matrix \eqn{C} specifying linear constraints
to the autoregressive parameters. The constraints are of the form
\eqn{(\varphi_{1},...,\varphi_{M}) = C\psi}, where \eqn{\varphi_{m} = (vec(A_{m,1}),...,vec(A_{m,p})) \ (pd^2 x 1),\ m=1,...,M},
contains the coefficient matrices and \eqn{\psi} \eqn{(q x 1)} contains the related parameters.
For example, to restrict the AR-parameters to be the identical across the regimes, set \eqn{C =}
[\code{I:...:I}]' \eqn{(Mpd^2 x pd^2)} where \code{I = diag(p*d^2)}.}

\item{mean_constraints}{Restrict the mean parameters of some regimes to be identical? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
\code{M=3}, the argument \code{list(1, 2:3)} restricts the mean parameters of the second and third regime to be
identical but the first regime has freely estimated (unconditional) mean. Ignore or set to \code{NULL} if mean parameters
should not be restricted to be the same among any regimes. \strong{This constraint is available only for mean parametrized models;
that is, when \code{parametrization="mean"}.}}

\item{weight_constraints}{a list of two elements, \eqn{R} in the first element and \eqn{r} in the second element,
specifying linear constraints on the transition weight parameters \eqn{\alpha}.
The constraints are of the form \eqn{\alpha = R\xi + r}, where \eqn{R} is a known \eqn{(a\times l)}
constraint matrix of full column rank (\eqn{a} is the dimension of \eqn{\alpha}), \eqn{r} is a known \eqn{(a\times 1)} constant,
and \eqn{\xi} is an unknown \eqn{(l\times 1)} parameter. \strong{Alternatively}, set \eqn{R=0} in order to constrain the
the weight parameter to the constant \eqn{r} (in this case, \eqn{\alpha} is dropped from the constrained parameter vector).}

\item{nrounds}{the number of estimation rounds that should be performed.}

\item{ncores}{the number CPU cores to be used in parallel computing.}

\item{maxit}{the maximum number of iterations in the variable metric algorithm.}

\item{seeds}{a length \code{nrounds} vector containing the random number generator seed
for each call to the genetic algorithm, or \code{NULL} for not initializing the seed.}

\item{print_res}{should summaries of estimation results be printed?}

\item{use_parallel}{employ parallel computing?}

\item{filter_estimates}{should the likely inappropriate estimates be filtered? See details.}

\item{...}{additional settings passed to the function \code{GAfit} employing the genetic algorithm.}
}
\value{
Returns an object of class \code{'stvar'} defining the estimated reduced form smooth transition VAR model.
}
\description{
\code{fitSTVAR} estimates a reduced form smooth transition VAR model in two phases:
  in the first phase, it uses a genetic algorithm to find starting values for a gradient based
  variable metric algorithm, which it then uses to finalize the estimation in the second phase.
  Parallel computing is utilized to perform multiple rounds of estimations in parallel.
}
\details{
If you wish to estimate a structural model, estimate first the reduced form model and then use the
 use the function \code{fitSSTVAR} to estimate the structural model based on the estimated reduced form model.

 Because of complexity and high multimodality of the log-likelihood function, it is \strong{not certain}
 that the estimation algorithm will end up in the global maximum point. It is expected that most of the
 estimation rounds will end up in some local maximum or saddle point instead. Therefore, a (sometimes large)
 number of estimation rounds is required for reliable results. Because of the nature of the model,
 the estimation may fail especially in the cases where the number of regimes is chosen too large.

 The estimation process is computationally heavy and it might take considerably long time for large models with
 large number of observations. If the iteration limit \code{maxit} in the variable metric algorithm is reached,
 one can continue the estimation by iterating more with the function \code{iterate_more}. Alternatively, one may
 use the found estimates as starting values for the genetic algorithm and and employ another round of estimation
 (see \code{??GAfit} how to set up an initial population with the dot parameters).

 \strong{If the estimation algorithm performs poorly (or fails to create an initial population for the genetic algorithm)},
 it usually helps to scale the individual series so that they vary roughly in the same scale.
 This makes it is easier to draw reasonable AR coefficients and (with some weight functions) weight parameter values.
 Even if one is able to create an initial population, it should be preferred to scale the series so that most of the
 AR coefficients will not be very large, as the estimation algorithm works better with relatively small AR coefficients.
 If needed, another package can be used to fit linear VARs to the series to see which scaling of the series results in
 relatively small AR coefficients. You may want to avoid very small (or very high) variability as well.

 \strong{weight_constraints:} If you are using weight constraints other than restricting some of the weight parameters to known
 constants, make sure the constraints are sensible. Otherwise, the estimation may fail due to the estimation algorithm not being
 able to generate reasonable random guesses for the values of the constrained weight parameters.

 \strong{Filtering inappropriate estimates:} If \code{filter_estimates == TRUE}, the code will automatically filter
 through estimates that it deems "inappropriate". That is, estimates that are not likely solutions of interest.
 Specifically, solutions that incorporate a near-singular error term covariance matrix (any eigenvalue less than \eqn{0.002})
 or transition weights such that they are close to zero for almost all \eqn{t} for at least one regime.
 You are welcome to set \code{filter_estimates=FALSE} and find the solutions of interest yourself by using the
 function \code{alt_stvar}.

 \strong{weight_constraints}
}
\section{S3 methods}{

  The following S3 methods are supported for class \code{'stvar'}: \code{logLik}, \code{residuals}, \code{print}, \code{summary},
   \code{predict}, \code{simulate}, and \code{plot}.
}

\section{About the warning "chol()}{
 given matrix is not symmetric":
 Sometimes the function produces warnings "chol(): given matrix is not symmetric" because sometimes the underlying C++ code
 calculating conditional covariance matrices notices that due to numerical error in the float-point representation, the matrix
 is not symmetric. The warning is produces even if symmetricity is forced with arma::symmatu() (and .eval()), so there seems to be some
 issue with the LAPACK library that arma::chol uses to check that the matrix is symmetric. It is necessary to take the decomposition
 in C++ for computational efficiency in order to calculate its inverse for each t in each evaluation of the log-likelihood function.
 These warnings can be ignored.
}

\examples{
\donttest{
## These are long running examples that use parallel computing!
# Running all the below examples will take approximately FILL IN HOW MANY minutes.
# When estimating the models to data, typically a large number of estimation
# rounds (set by the argumetn 'nround') should be used. These examples use
# only one round to decrease the running time of the examples.

# p=3, M=2, d=2 relative_dens Gaussian STVAR
fit32 <- fitSTVAR(gdpdef, p=3, M=2, weight_function="relative_dens",
 cond_dist="Gaussian", nrounds=1, seeds=1, use_parallel=FALSE)
fit32
summary(fit32)
plot(fit32)

# p=1, M=2, d=2 relative_dens Gaussian STVAR with the AR matrices
# constrained to be identical in both regimes
C_122 <- rbind(diag(1*2^2), diag(1*2^2))
fit12c <- fitSTVAR(gdpdef, p=1, M=2, AR_constraints=C_122, nrounds=1, seeds=1,
  use_parallel=FALSE)

# p=1, M=2, d=2 relative_dens Gaussian STVAR with the means and AR matrices constrained
# to be identical in both regimes
fit12cm <- fitSTVAR(gdpdef, p=1, M=2, AR_constraints=C_122, mean_constraints=list(1:2),
 nrounds=1, seeds=1, use_parallel=FALSE)

# p=2, M=2, d=2, relative_dens Gaussian STVAR; constrain AR-parameters to be the same
# for all regimes and constrain the of-diagonal elements of AR-matrices to be zero.
mat0 <- matrix(c(1, rep(0, 10), 1, rep(0, 8), 1, rep(0, 10), 1), nrow=2*2^2, byrow=FALSE)
C_222 <- rbind(mat0, mat0)
fit22c <- fitSTVAR(gdpdef, p=2, M=2, AR_constraints=C_222, nrounds=1, seeds=1, use_parallel=FALSE)

# p=2, M=2, d=2, constrain AR-parameters to be the same for all regimes
# and constrain the of-diagonal elements of AR-matrices to be zero. Moreover,
# constrain the means identical in both regimes.
fit22cm <- fitSTVAR(gdpdef, p=2, M=2, AR_constraints=C_222, mean_constraints=list(1:2),
  nrounds=1, seeds=1, use_parallel=FALSE)

# p=3, M=2, d=2, logistic Student's t STVAR with the second variable as switching variable
# with one lag.
fitlogistict32 <- fitSTVAR(gdpdef, p=3, M=2, weight_function="logistic", weightfun_pars=c(2, 1),
 cond_dist="Student", nrounds=1, seeds=1, use_parallel=FALSE)

# p=3, M=2, d=2, logistic STVAR with the second variable as switching variable
# with one lag, and the location parameter constrained to 1 and scale parameter unconstrained.
fitlogistic32w <- fitSTVAR(gdpdef, p=3, M=2, weight_function="logistic", weightfun_pars=c(2, 1),
 weight_constraints=list(R=matrix(c(0, 1), nrow=2), r=c(1, 0)), nrounds=1, seeds=1,
 use_parallel=FALSE)

# mlogit STVAR, p=3, M=2, d=2, the second variable is the switching variable with one lag.
fitmlogit32 <- fitSTVAR(gdpdef, p=3, M=2, weight_function="mlogit",
 weightfun_pars=list(vars=2, lags=1), nrounds=1, seeds=1, use_parallel=FALSE)

# mlogit Student STVAR, p=3, M=2, d=2, the second variable is the switching variable with two lags,
# constrain AR matrices equal across the regimes.
C_322 <- rbind(diag(3*2^2), diag(3*2^2))
fitmlogit32ct <- fitSTVAR(gdpdef, p=3, M=2, weight_function="mlogit",
 weightfun_pars=list(vars=2, lags=2), cond_dist="Student", AR_constraints=C_322, nrounds=1, seeds=1,
 use_parallel=FALSE)

# relative_dens STVAR, p=1, M=2, d=2, with the weight parameter fixed to the constant r=0.8.
fit12w <- fitSTVAR(gdpdef, p=1, M=2, weight_constraints=list(R=0, r=0.8), nrounds=1, seeds=9,
 use_parallel=FALSE)

# p=3, M=2, d=2, exponential STVAR with the second variable as switching variable
# with one lag, and AR parameter constrained identical across the regimes, means constrained
# identical across the regimes, and the location parameter constrained to 0.5.
fitexp32cmw <- fitSTVAR(gdpdef, p=3, M=2, weight_function="exponential", weightfun_pars=c(2, 1),
  AR_constraints=C_322, mean_constraints=list(1:2),
  weight_constraints=list(R=matrix(c(0, 1), nrow=2), r=c(0.5, 0)),
  cond_dist="Student", nrounds=1, seeds=1, use_parallel=FALSE)

# p=3, M=2, d=2, threshold Student's t STVAR with the second variable as the switching variable
# with one lag, and the threshold parameter constained to 1.
fitthres32wt <- fitSTVAR(gdpdef, p=3, M=2, weight_function="threshold", weightfun_pars=c(2, 1),
  cond_dist="Student", weight_constraints=list(R=0, r=1), nrounds=1, seeds=2, use_parallel=FALSE)
}
}
\references{
\itemize{
   \item FILL IN REFEENCES
 }
}
\seealso{
\code{\link{GAfit}},  \code{\link{iterate_more}}
}
